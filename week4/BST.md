# Data Structures & Binary Search Trees

## Office Hour

- Q & A
- Closures and Memoization and Currying

## Objectives

- Understand data structures and the different types there are.
- Learn about Binary Search Trees and How they are used
- Code out a Binary Search Tree together


## Lecture

### Data Structures

1. Arrays: Arrays are the simplest data structure and provide a foundation for understanding data storage. Teach them about indexing, element access, and basic operations like insertion and deletion.

2. Lists: Introduce linked lists, which are dynamic data structures that can grow or shrink. Teach singly linked lists first and then move on to doubly linked lists. This helps students understand memory management and pointers.

3. Stacks: Stacks are linear data structures that follow the Last-In, First-Out (LIFO) principle. They are essential for understanding function calls and managing program execution.

4. Queues: Queues are linear data structures that follow the First-In, First-Out (FIFO) principle. Teach both basic queues and priority queues to demonstrate different use cases.

5. Trees: Start with binary trees, explaining the concept of nodes, roots, leaves, and branches. From there, move on to binary search trees to introduce the idea of ordering. Then, discuss more complex trees like AVL trees or Red-Black trees.

6. Graphs: Introduce the concept of nodes and edges, explaining both directed and undirected graphs. Teach basic graph traversal algorithms like Depth-First Search (DFS) and Breadth-First Search (BFS).

7. Hash Tables: Teach the concept of hashing and how it's used for efficient data retrieval. Explain collision resolution techniques, such as chaining or open addressing.

8. Heaps: Explain the concept of binary heaps, including min-heaps and max-heaps. These data structures are important for priority queues and heapsort.

9. Trie: Introduce the trie data structure, which is used for efficient string searches. It's a good opportunity to discuss memory optimization and tree-based data structures.

10. Sets and Maps: Discuss sets and maps (or dictionaries) and their implementations in various programming languages. Emphasize their use in solving real-world problems.

11. Dynamic Arrays: Show how dynamic arrays (e.g., ArrayList in Java or std::vector in C++) work internally. This can help students understand how resizing and memory management are handled.

12. Linked Hash Map: Combining concepts from linked lists and hash tables, a linked hash map provides an excellent example of a practical data structure.

13. Bloom Filters: Introduce probabilistic data structures like Bloom filters, which are useful for membership testing.

14. Self-balancing Trees: Further explore self-balancing trees like AVL trees and Red-Black trees, emphasizing their role in maintaining balanced structures.

15. Graph Algorithms: Dive deeper into graph algorithms, covering topics like Dijkstra's algorithm, Kruskal's algorithm, and topological sorting.

16. Advanced Data Structures: Depending on the students' proficiency and interest, you can introduce more advanced data structures like B-trees, skip lists, or specialized data structures for specific applications.

### Binary Sort Tree

- Anatomy - BST
    - root

- Anatomy - BSTNode
    - value
    - left
    - right

- ADD method
    - recursion necessary



